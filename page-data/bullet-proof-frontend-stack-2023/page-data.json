{"componentChunkName":"component---src-templates-blog-post-js","path":"/bullet-proof-frontend-stack-2023/","webpackCompilationHash":"a8d62280f1fd0ee764bb","result":{"data":{"site":{"siteMetadata":{"title":"Erwin Smit blog","author":"Erwin Smit"}},"markdownRemark":{"id":"c989fcb3-2b48-593a-9bde-169476cf7279","html":"<p>My frontend stack in 2023, what are my choices and the reasoning behind them:</p>\n<h2 id=\"the-basics-same-old-every-year\"><a href=\"#the-basics-same-old-every-year\" aria-label=\"the basics same old every year permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The basics, same-old every year</h2>\n<ul>\n<li><strong>React</strong></li>\n</ul>\n<p>React is still the safe choice, it’s by far the most popular framework for building the components for the view in any project.\nYes, Svelte, Vue, and Angular are all great too. But is there something those frameworks can do that React can’t? </p>\n<ul>\n<li><strong>Typescript</strong></li>\n</ul>\n<p>Typescript is a no-brainer. There are no serious alternatives.</p>\n<h2 id=\"components\"><a href=\"#components\" aria-label=\"components permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Components</h2>\n<p>After doing some revision on custom build components (e.g. Accordions, Modals, etc) for accessibility improvements I made the decision I’m never going to build common UI patterns from scratch. </p>\n<p>So for some projects, I have used UI libraries. Mainly <a href=\"https://mui.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">MUI</a> and <a href=\"https://react.fluentui.dev/?path=/docs/concepts-introduction--page\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">FluentUI</a>. The developer experience with these libraries is great, you get accessibility out of the box, and the components are well thought out and flexible enough to match custom designs. However, they also have a problem called <strong>CSS in JS</strong>. More about this problem below (Styling). </p>\n<p>In the new composable world let’s also make our components composable with a <strong>Headless UI</strong>.</p>\n<p>Therefore I choose to work with <a href=\"https://www.radix-ui.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Radix</a>, a great library that covers the basic functionalities you need on every project (Tabs, Tooltip, etc) but can be styled with your favorite styling approach. </p>\n<p>Other libraries that do the same thing: <a href=\"https://react-spectrum.adobe.com/react-aria/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React Aria</a>, <a href=\"https://headlessui.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Headless UI</a>, and <a href=\"https://reach.tech/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Reach UI</a>.</p>\n<h2 id=\"styling\"><a href=\"#styling\" aria-label=\"styling permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Styling</h2>\n<p>I have been a big fan of <strong>CSS in JS</strong> as an alternative to the SCSS projects using <a href=\"https://getbem.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">BEM</a>. I love the fact that I don’t have to switch contexts when I’m using variables in CSS or in TSX. Also, automatic refactoring and the “find all references” button in CSS code is something I would always miss writing SCSS/BEM. </p>\n<p>But, CSS in JS is not a good bet anymore. It’s strongly discouraged to use CSS in JS with React server components.\nOlder server-side technologies have issues with CSS in JS too (e.g. <a href=\"https://github.com/reactjs/React.NET/issues/970\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React.NET</a>). </p>\n<p><a href=\"https://dev.to/srmagura/why-were-breaking-up-wiht-css-in-js-4g9b\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Good read from one of the Emotion maintainers</a> (<a href=\"https://emotion.sh/docs/introduction\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Emotion</a> is the engine behind MUI):</p>\n<p>In my opinion, it would be a bad decision to build your front end using this technique if there is a chance it has to be server-side generated one day.</p>\n<p>Unless I’m 100% sure the components are always used client-side only, I don’t like to take that risk. Since we already have nice functional components from Radix (or another Headless UI) we just need CSS to make them look good. </p>\n<p>What are my options?</p>\n<h3 id=\"scss-with-bem\"><a href=\"#scss-with-bem\" aria-label=\"scss with bem permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SCSS with BEM</h3>\n<p>Is of course capable of making the components look good, but I don’t like to step back in developer experience. I have also seen too many projects where knowledge about the architecture was required to apply clean changes. As a result, when other developers worked on the project and applied quick changes, the quality of the codebase degraded making maintenance and future development hard. Plus, the mental effort it takes to come up with classes like “inner”, “container” and “wrapper” feel like a waste. </p>\n<h3 id=\"tailwind\"><a href=\"#tailwind\" aria-label=\"tailwind permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tailwind</h3>\n<p><a href=\"https://tailwindcss.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Tailwind</a> is great for its simplicity. It’s great for React components because you never have to leave your TSX file, it’s all right there. There is also no risk in breaking stuff by accident, everything is scoped to the component. But there are still two reasons that stop me from using Tailwind for a work project. </p>\n<ol>\n<li><strong>Controversy</strong></li>\n</ol>\n<p>Developers who always took pride in setting up a clean SCSS architecture with nice names often hate Tailwind. I still want to be friends with those developers. </p>\n<ol start=\"2\">\n<li><strong>Typescript?</strong></li>\n</ol>\n<p>You either need to become very good in mesmerizing Tailwind classes or use tooling to work well with Tailwind. There is also no compiler that slaps you in the face when you misspell a classname. </p>\n<h3 id=\"vanilla-extract\"><a href=\"#vanilla-extract\" aria-label=\"vanilla extract permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Vanilla Extract</h3>\n<p>In my opinion, <a href=\"https://vanilla-extract.style/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Vanilla Extract</a> is a good “Everyone’s friend”. CSS in JS fans will like the Typescript support and the SCSS/BEM crew will like the way it’s just like regular CSS and create nice descriptive class names. When switching from Tsx to Css.ts extensions I love the fact I don’t have to switch syntax for accessing theme variables. When I access a theme variable that doesn’t exist, the compiler will punish me for doing so but VS Code will warn me beforehand (unlike with SCSS). </p>\n<p>There are other tools that work in a similar way (<a href=\"https://stitches.dev/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Stitches</a>, <a href=\"https://panda-css.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Panda CSS</a>). I don’t really care if I ever have to use another one as they are all pretty similar. It’s just a nice Typescript layer over regular CSS Modules. </p>\n<h2 id=\"monorepo\"><a href=\"#monorepo\" aria-label=\"monorepo permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Monorepo</h2>\n<p>For monorepos, I like to use <a href=\"https://nx.dev/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">NX</a>, I have used Lerna and NPM workspaces in the past. They also worked fine, but I had to think and do more stuff myself. </p>\n<p>NX delivers out of the box a nice developer experience with scaffolding scripts, task runners, etc. Monorepos helped me in creating isolated “UI component” packages, I will explain in a later blog post why I’m a fan of this. </p>","timeToRead":4,"frontmatter":{"title":"My frontend stack in 2023","date":"August 31, 2023","spoiler":"My frontend stack in 2023, what are my choices and the reasoning behind them"},"fields":{"slug":"/bullet-proof-frontend-stack-2023/","langKey":"en"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/bullet-proof-frontend-stack-2023/","previous":{"fields":{"slug":"/speed-up-sitecore-jss-nextjs-local-development/","langKey":"en","directoryName":"speed-up-sitecore-jss-nextjs-local-development"},"frontmatter":{"title":"Speed up Sitecore JSS Next.js local development"}},"next":{"fields":{"slug":"/xmcloud-nextjs-multisite-styling/","langKey":"en","directoryName":"xmcloud-nextjs-multisite-styling"},"frontmatter":{"title":"Sitecore XM Cloud multisite styling"}},"translations":[],"translatedLinks":[]}}}